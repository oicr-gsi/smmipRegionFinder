# -*- coding: utf-8 -*-
"""
Created on Mon Mar 22 09:44:19 2021

@author: rjovelin
"""

import argparse
import os



def read_panel(smmip_panel):
    '''
    (str) -> dict
    
    Returns a dictionary storing information about the smmips using >mip_key as key
    Precondition: smmip_panel is a tab delimited file and expected column names are present
    
    Parameters
    ----------
    - smmip_panel (str): Path to file with smmip information.
                         File generated by MIPGEN. Contains info about the smmips
                         included in the panel 
    '''
    
    D = {}
    infile = open(smmip_panel)
    header = infile.readline().rstrip().split('\t')
    
    for line in infile:
        line = line.rstrip()
        if line != '':
            line = line.split('\t')
            # get smmip key
            mip_key = line[header.index('>mip_key')]
            D[mip_key] = {i: line[header.index(i)] for i in header}
            # convert types
            for i in D[mip_key]:
                if i == 'logistic_score':
                    D[mip_key][i] = float(D[mip_key][i])
                # convert length to int
                elif i in ['target length', 'lig arm length', 'ext arm length',
                           'for primer length', 'rev primer length', 'umi length',
                           'pcr product length']:
                    D[mip_key][i] = int(D[mip_key][i])
                # convert coordinates to 0-based
                elif i in ['ext_probe_start', 'ext_probe_stop', 'lig_probe_start',
                           'lig_probe_stop', 'mip_scan_start_position', 'mip_scan_stop_position',
                           'feature_start_position', 'feature_stop_position']:
                    if 'start' in i:
                        D[mip_key][i] = int(D[mip_key][i]) - 1
                    elif 'stop' in i:
                        D[mip_key][i] = int(D[mip_key][i])
                elif i == 'chr':
                    if 'chr' not in D[mip_key][i].lower():
                        D[mip_key][i] = 'chr' + D[mip_key][i]
    infile.close()
    return D


def collect_smmip_regions(panel):
    '''
    (dict) -> dict
    
    Returns a dictionary with the coordinates of each smmip on each chromosome in the panel
    
    
    
    Parameters
    ----------
    - panel (dict): Information about each smmip in the panel
    '''
    
    D = {}

    for i in panel:
        chromo = panel[i]['chr']
        if chromo not in D:
            D[chromo] = []
        # smmip cordinates depend on strand orientation
        if panel[i]['probe_strand'] == '+':
            start, end = panel[i]['ext_probe_start'], panel[i]['lig_probe_stop']
        elif panel[i]['probe_strand'] == '-':
            start, end = panel[i]['lig_probe_start'], panel[i]['ext_probe_stop']
        D[chromo].append([start, end])
    
    # sort all coordinates on each chromosome
    for chromo in D:
        D[chromo].sort()

    return D


def group_smmips(smmips_coordinates, distance):
    '''
    (dict, int) -> dict
    
    Groups smmips by the distance between them on each chromosome. 
    Returns a dictionary with lists of smmip coordinates in which the distance
    between 2 adjacent smmips is <= distance
    
    Parameters
    ----------
    - smmips_coordinates (dict): Dictionary with 
    - distance (int): Distance threshold to group 2 adjacent smmips
    '''
        
    D = {}
    for chromo in smmips_coordinates:
        # initialize a group of smmips
        group = []
        # loop over smmips on chromo
        for i in range(len(smmips_coordinates[chromo])):
            # collect first smmip
            if len(group) == 0:
                 group.append(smmips_coordinates[chromo][i])
            # compare ith smmip with its i+1th neighbor
            if i != len(smmips_coordinates[chromo]) -1:
                # group smmips at i and i+1 if separated by <= distance
                if smmips_coordinates[chromo][i+1][0] - smmips_coordinates[chromo][i][1] <= distance:
                    # collect coordinates of smmip at i if not already recorded
                    if smmips_coordinates[chromo][i] not in group:
                        group.append(L[chromo][i])
                    # collect immediate i+1th neighbor
                    group.append(smmips_coordinates[chromo][i+1])
                else:
                    # record group if separated > distance and start new group
                    if chromo not in D:
                        D[chromo] = []
                    D[chromo].append(group)
                    group = []
            # add coordinates of last smmip if not already recorded and record group
            else:
                if smmips_coordinates[chromo][i] not in group:
                    group.append(smmips_coordinates[chromo][i])
                if chromo not in D:
                    D[chromo] = []
                D[chromo].append(group)
    return D
            
def collapse_regions(groups):
    '''
    (dict) -> dict
    
    Collapse all smmips within a group into a single region.
    Returns a dictionary with the coordinates of each group of smmips
    
    Parameters
    ----------
    - groups (dict): A dictionary with chromosomes as key and a list of smmips coordinates 
    grouped by distance
    '''
    
    
    D = {}
    for chromo in groups:
        for region in groups[chromo]:
            start, end = region[0][0], region[-1][1]
            if chromo not in D:
                D[chromo] = []
            D[chromo].append([start, end])
    return D


def add_buffer(regions, distance):
    '''
    (dict, int) -> dict
    
    Adds a buffer of size distance around the smmip regions coordinates
    Returns the dictionary with region coordinates with added buffer
    
    Parameters
    ----------
    - regions (dict): Dictionary with coordinates of each smmip region grouping smmip by distance
    - distance (int): Length of the buffer to add around the region coordinates
    '''
    
    for chromo in regions:
        for i in range(len(regions[chromo])):
            # add buffer around coordinates
            start = regions[chromo][i][0] - distance
            if start < 0:
                start = 0
            end = regions[chromo][i][1] + distance
            regions[chromo][i] = [start, end]
    return regions


def find_smmips_regions(smmip_panel, distance, outdir):
    '''
    (str, int, str | None) -> None
    
    Write a bed file with the coordinates for each smmip region that includes neighboring smmips
    distant from distance or less. Each region is buffered with distance.
    
    Parameters
    ----------
    - smmip_panel (str): Path to panel file with smmip information
    - distance (int): Minimum distance between smmips and buffer around region coordinates
    - outdir (str | None): Directory where to save the bed file with region coordinates
    '''
    
    distance = int(distance)
    
    # read panel
    panel = read_panel(smmip_panel)
    # collect smmip coordinates on each chromosome
    smmips_coordinates = collect_smmip_regions(panel)
    # group smmips by distance
    groups = group_smmips(smmips_coordinates, distance)
    # get the coordinates of the regions for each group
    regions = collapse_regions(groups)
    # add a buffer around the region coordinates
    regions = add_buffer(regions, distance)
    # make a list of coordinates for each region [chromo, start, end]
    L = []
    for chromo in regions:
        for region in regions[chromo]:
            L.append([chromo, str(region[0]), str(region[1])])
    L.sort()
    
    outputfile = 'smmipRegions_{0}.bed'.format(str(distance))
    if outdir:
        outputfile = os.path.join(outdir, outputfile)
    newfile = open(outputfile, 'w')
    for i in L:
        newfile.write('\t'.join(i) + '\n')
    newfile.close()

if __name__ == '__main__':
    parser = argparse.ArgumentParser(prog='smmipRegionFinder.py', description="A script to identify regions with smmips grouped by distance from a smmip panel")
    
    parser.add_argument('-d', '--distance', dest='distance', default=200, help = 'Minimum distance between smmips and buffer around region coordinates. Should be greater than read length. Default is 200bp')
    parser.add_argument('-p', '--panel', dest='panel', help = 'Path to panel file with smmip information', required=True)
    parser.add_argument('-o', '--outdir', dest='outdir', help = 'Directory where to save the bed file with region coordinates')
        
    args = parser.parse_args()
    
    try:
        find_smmips_regions(args.panel, args.distance, args.outdir)
    except AttributeError as e:
        print('#############\n')
        print('AttributeError: {0}\n'.format(e))
        print('#############\n\n')
        print(parser.format_help())
    